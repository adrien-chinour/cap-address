<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  CapAddress\Address
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * CAP ADDRESS
 *
 * CAP ADDRESS permet, en temps réel, d'assister l'utilisateur lors de la saisie d'une adresse et de s'assurer de la validité de cette dernière avant de la stocker en base de données. Ainsi que de vérifier l'intégralité d'une adresse, en temps réel, lors de la validation.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@capadresse.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CapAddress\Address\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use CapAddress\Address\ApiException;
use CapAddress\Address\Configuration;
use CapAddress\Address\HeaderSelector;
use CapAddress\Address\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  CapAddress\Address
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getMessageGet
     *
     * Gestion des messages
     *
     * @param  string $request request (required)
     * @param  string $message_code Valeur retournée par la fonction appelée précédemment. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les messages. (required)
     *
     * @throws \CapAddress\Address\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CapAddress\Address\Model\InlineResponse200
     */
    public function getMessageGet($request, $message_code, $language_code)
    {
        list($response) = $this->getMessageGetWithHttpInfo($request, $message_code, $language_code);
        return $response;
    }

    /**
     * Operation getMessageGetWithHttpInfo
     *
     * Gestion des messages
     *
     * @param  string $request (required)
     * @param  string $message_code Valeur retournée par la fonction appelée précédemment. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les messages. (required)
     *
     * @throws \CapAddress\Address\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CapAddress\Address\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageGetWithHttpInfo($request, $message_code, $language_code)
    {
        $returnType = '\CapAddress\Address\Model\InlineResponse200';
        $request = $this->getMessageGetRequest($request, $message_code, $language_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CapAddress\Address\Model\InlineResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMessageGetAsync
     *
     * Gestion des messages
     *
     * @param  string $request (required)
     * @param  string $message_code Valeur retournée par la fonction appelée précédemment. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les messages. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageGetAsync($request, $message_code, $language_code)
    {
        return $this->getMessageGetAsyncWithHttpInfo($request, $message_code, $language_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageGetAsyncWithHttpInfo
     *
     * Gestion des messages
     *
     * @param  string $request (required)
     * @param  string $message_code Valeur retournée par la fonction appelée précédemment. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les messages. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageGetAsyncWithHttpInfo($request, $message_code, $language_code)
    {
        $returnType = '\CapAddress\Address\Model\InlineResponse200';
        $request = $this->getMessageGetRequest($request, $message_code, $language_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessageGet'
     *
     * @param  string $request (required)
     * @param  string $message_code Valeur retournée par la fonction appelée précédemment. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les messages. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMessageGetRequest($request, $message_code, $language_code)
    {
        // verify the required parameter 'request' is set
        if ($request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling getMessageGet'
            );
        }
        // verify the required parameter 'message_code' is set
        if ($message_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_code when calling getMessageGet'
            );
        }
        // verify the required parameter 'language_code' is set
        if ($language_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language_code when calling getMessageGet'
            );
        }

        $resourcePath = '/GetMessage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request !== null) {
            $queryParams['request'] = ObjectSerializer::toQueryValue($request);
        }
        // query params
        if ($message_code !== null) {
            $queryParams['messageCode'] = ObjectSerializer::toQueryValue($message_code);
        }
        // query params
        if ($language_code !== null) {
            $queryParams['languageCode'] = ObjectSerializer::toQueryValue($language_code);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAddressGet
     *
     * Aide à la saisie d'adresses en temps réel
     *
     * @param  string $request request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \CapAddress\Address\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CapAddress\Address\Model\SearchAddressResponse
     */
    public function searchAddressGet($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        list($response) = $this->searchAddressGetWithHttpInfo($request, $step, $country_code, $language_code, $input_output, $quality_code, $locality_synonym, $locality_id, $locality, $postal_code, $locality_flags, $street_id, $street_name, $street_flags, $street_type, $street_synonym, $street_info_1, $street_info_2, $street_info_5, $street_number, $street_number_id, $street_number_ext, $building_id, $building_name, $building_info_1, $company_id, $company, $company_info_1, $company_info_2, $additional_info_7);
        return $response;
    }

    /**
     * Operation searchAddressGetWithHttpInfo
     *
     * Aide à la saisie d'adresses en temps réel
     *
     * @param  string $request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \CapAddress\Address\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CapAddress\Address\Model\SearchAddressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchAddressGetWithHttpInfo($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        $returnType = '\CapAddress\Address\Model\SearchAddressResponse';
        $request = $this->searchAddressGetRequest($request, $step, $country_code, $language_code, $input_output, $quality_code, $locality_synonym, $locality_id, $locality, $postal_code, $locality_flags, $street_id, $street_name, $street_flags, $street_type, $street_synonym, $street_info_1, $street_info_2, $street_info_5, $street_number, $street_number_id, $street_number_ext, $building_id, $building_name, $building_info_1, $company_id, $company, $company_info_1, $company_info_2, $additional_info_7);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CapAddress\Address\Model\SearchAddressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAddressGetAsync
     *
     * Aide à la saisie d'adresses en temps réel
     *
     * @param  string $request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAddressGetAsync($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        return $this->searchAddressGetAsyncWithHttpInfo($request, $step, $country_code, $language_code, $input_output, $quality_code, $locality_synonym, $locality_id, $locality, $postal_code, $locality_flags, $street_id, $street_name, $street_flags, $street_type, $street_synonym, $street_info_1, $street_info_2, $street_info_5, $street_number, $street_number_id, $street_number_ext, $building_id, $building_name, $building_info_1, $company_id, $company, $company_info_1, $company_info_2, $additional_info_7)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAddressGetAsyncWithHttpInfo
     *
     * Aide à la saisie d'adresses en temps réel
     *
     * @param  string $request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAddressGetAsyncWithHttpInfo($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        $returnType = '\CapAddress\Address\Model\SearchAddressResponse';
        $request = $this->searchAddressGetRequest($request, $step, $country_code, $language_code, $input_output, $quality_code, $locality_synonym, $locality_id, $locality, $postal_code, $locality_flags, $street_id, $street_name, $street_flags, $street_type, $street_synonym, $street_info_1, $street_info_2, $street_info_5, $street_number, $street_number_id, $street_number_ext, $building_id, $building_name, $building_info_1, $company_id, $company, $company_info_1, $company_info_2, $additional_info_7);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchAddressGet'
     *
     * @param  string $request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchAddressGetRequest($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        // verify the required parameter 'request' is set
        if ($request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling searchAddressGet'
            );
        }
        // verify the required parameter 'step' is set
        if ($step === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step when calling searchAddressGet'
            );
        }
        // verify the required parameter 'country_code' is set
        if ($country_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_code when calling searchAddressGet'
            );
        }
        // verify the required parameter 'language_code' is set
        if ($language_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language_code when calling searchAddressGet'
            );
        }

        $resourcePath = '/SearchAddress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request !== null) {
            $queryParams['request'] = ObjectSerializer::toQueryValue($request);
        }
        // query params
        if ($input_output !== null) {
            $queryParams['inputOutput'] = ObjectSerializer::toQueryValue($input_output);
        }
        // query params
        if ($step !== null) {
            $queryParams['step'] = ObjectSerializer::toQueryValue($step);
        }
        // query params
        if ($country_code !== null) {
            $queryParams['countryCode'] = ObjectSerializer::toQueryValue($country_code);
        }
        // query params
        if ($language_code !== null) {
            $queryParams['languageCode'] = ObjectSerializer::toQueryValue($language_code);
        }
        // query params
        if ($quality_code !== null) {
            $queryParams['qualityCode'] = ObjectSerializer::toQueryValue($quality_code);
        }
        // query params
        if ($locality_synonym !== null) {
            $queryParams['localitySynonym'] = ObjectSerializer::toQueryValue($locality_synonym);
        }
        // query params
        if ($locality_id !== null) {
            $queryParams['localityId'] = ObjectSerializer::toQueryValue($locality_id);
        }
        // query params
        if ($locality !== null) {
            $queryParams['locality'] = ObjectSerializer::toQueryValue($locality);
        }
        // query params
        if ($postal_code !== null) {
            $queryParams['postalCode'] = ObjectSerializer::toQueryValue($postal_code);
        }
        // query params
        if ($locality_flags !== null) {
            $queryParams['localityFlags'] = ObjectSerializer::toQueryValue($locality_flags);
        }
        // query params
        if ($street_id !== null) {
            $queryParams['streetId'] = ObjectSerializer::toQueryValue($street_id);
        }
        // query params
        if ($street_name !== null) {
            $queryParams['streetName'] = ObjectSerializer::toQueryValue($street_name);
        }
        // query params
        if ($street_flags !== null) {
            $queryParams['streetFlags'] = ObjectSerializer::toQueryValue($street_flags);
        }
        // query params
        if ($street_type !== null) {
            $queryParams['streetType'] = ObjectSerializer::toQueryValue($street_type);
        }
        // query params
        if ($street_synonym !== null) {
            $queryParams['streetSynonym'] = ObjectSerializer::toQueryValue($street_synonym);
        }
        // query params
        if ($street_info_1 !== null) {
            $queryParams['streetInfo_1'] = ObjectSerializer::toQueryValue($street_info_1);
        }
        // query params
        if ($street_info_2 !== null) {
            $queryParams['streetInfo_2'] = ObjectSerializer::toQueryValue($street_info_2);
        }
        // query params
        if ($street_info_5 !== null) {
            $queryParams['streetInfo_5'] = ObjectSerializer::toQueryValue($street_info_5);
        }
        // query params
        if ($street_number !== null) {
            $queryParams['streetNumber'] = ObjectSerializer::toQueryValue($street_number);
        }
        // query params
        if ($street_number_id !== null) {
            $queryParams['streetNumberId'] = ObjectSerializer::toQueryValue($street_number_id);
        }
        // query params
        if ($street_number_ext !== null) {
            $queryParams['streetNumberExt'] = ObjectSerializer::toQueryValue($street_number_ext);
        }
        // query params
        if ($building_id !== null) {
            $queryParams['buildingId'] = ObjectSerializer::toQueryValue($building_id);
        }
        // query params
        if ($building_name !== null) {
            $queryParams['buildingName'] = ObjectSerializer::toQueryValue($building_name);
        }
        // query params
        if ($building_info_1 !== null) {
            $queryParams['buildingInfo_1'] = ObjectSerializer::toQueryValue($building_info_1);
        }
        // query params
        if ($company_id !== null) {
            $queryParams['companyId'] = ObjectSerializer::toQueryValue($company_id);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company_info_1 !== null) {
            $queryParams['companyInfo_1'] = ObjectSerializer::toQueryValue($company_info_1);
        }
        // query params
        if ($company_info_2 !== null) {
            $queryParams['companyInfo_2'] = ObjectSerializer::toQueryValue($company_info_2);
        }
        // query params
        if ($additional_info_7 !== null) {
            $queryParams['additionalInfo_7'] = ObjectSerializer::toQueryValue($additional_info_7);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchLineGet
     *
     * Aide à la saisie d'adresses en temps réel
     *
     * @param  string $request request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \CapAddress\Address\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CapAddress\Address\Model\SearchLineResponse
     */
    public function searchLineGet($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        list($response) = $this->searchLineGetWithHttpInfo($request, $step, $country_code, $language_code, $input_output, $quality_code, $locality_synonym, $locality_id, $locality, $postal_code, $locality_flags, $street_id, $street_name, $street_flags, $street_type, $street_synonym, $street_info_1, $street_info_2, $street_info_5, $street_number, $street_number_id, $street_number_ext, $building_id, $building_name, $building_info_1, $company_id, $company, $company_info_1, $company_info_2, $additional_info_7);
        return $response;
    }

    /**
     * Operation searchLineGetWithHttpInfo
     *
     * Aide à la saisie d'adresses en temps réel
     *
     * @param  string $request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \CapAddress\Address\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CapAddress\Address\Model\SearchLineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchLineGetWithHttpInfo($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        $returnType = '\CapAddress\Address\Model\SearchLineResponse';
        $request = $this->searchLineGetRequest($request, $step, $country_code, $language_code, $input_output, $quality_code, $locality_synonym, $locality_id, $locality, $postal_code, $locality_flags, $street_id, $street_name, $street_flags, $street_type, $street_synonym, $street_info_1, $street_info_2, $street_info_5, $street_number, $street_number_id, $street_number_ext, $building_id, $building_name, $building_info_1, $company_id, $company, $company_info_1, $company_info_2, $additional_info_7);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CapAddress\Address\Model\SearchLineResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchLineGetAsync
     *
     * Aide à la saisie d'adresses en temps réel
     *
     * @param  string $request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchLineGetAsync($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        return $this->searchLineGetAsyncWithHttpInfo($request, $step, $country_code, $language_code, $input_output, $quality_code, $locality_synonym, $locality_id, $locality, $postal_code, $locality_flags, $street_id, $street_name, $street_flags, $street_type, $street_synonym, $street_info_1, $street_info_2, $street_info_5, $street_number, $street_number_id, $street_number_ext, $building_id, $building_name, $building_info_1, $company_id, $company, $company_info_1, $company_info_2, $additional_info_7)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchLineGetAsyncWithHttpInfo
     *
     * Aide à la saisie d'adresses en temps réel
     *
     * @param  string $request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchLineGetAsyncWithHttpInfo($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        $returnType = '\CapAddress\Address\Model\SearchLineResponse';
        $request = $this->searchLineGetRequest($request, $step, $country_code, $language_code, $input_output, $quality_code, $locality_synonym, $locality_id, $locality, $postal_code, $locality_flags, $street_id, $street_name, $street_flags, $street_type, $street_synonym, $street_info_1, $street_info_2, $street_info_5, $street_number, $street_number_id, $street_number_ext, $building_id, $building_name, $building_info_1, $company_id, $company, $company_info_1, $company_info_2, $additional_info_7);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchLineGet'
     *
     * @param  string $request (required)
     * @param  string $step L&#39;étape correspondante à la recherche. (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $input_output Chaîne de caractères saisie par l&#39;utilisateur. (optional)
     * @param  string $quality_code Code qualité adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_synonym Lieu dit postal ou INSEE, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality_id Identifiant de localité (Code INSEE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $locality Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $postal_code Code Postal, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $locality_flags Type de couple Code Postal Localité, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_id Identifiant de voie (Matricule HEXAVIA), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_name Ligne 4 postale (voie), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  int $street_flags Type de synonyme de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_type Type de voie abrégé, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_synonym Ancienne dénomination de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_1 Mot directeur de la voie (dernier mot), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_2 Reste voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_info_5 Identifiant de la voie (Code HEXACLE VOIE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number Numéro de voie, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_id Identifiant du numéro de voie (Code HEXACLE), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $street_number_ext Complément du numéro, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_id Identifiant du bâtiment (Code HEXALIGNE3), élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $building_info_1 Informations additionnelles du bâtiment, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_id Numéro de dossier cedexa, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company Nom de la société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_1 Ligne 2 société, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $company_info_2 Boite Postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     * @param  string $additional_info_7 Ligne 5 postale, élément récupéré lors de l&#39;étape de recherche précédente via le tableau de sortie adresses. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchLineGetRequest($request, $step, $country_code, $language_code, $input_output = null, $quality_code = null, $locality_synonym = null, $locality_id = null, $locality = null, $postal_code = null, $locality_flags = null, $street_id = null, $street_name = null, $street_flags = null, $street_type = null, $street_synonym = null, $street_info_1 = null, $street_info_2 = null, $street_info_5 = null, $street_number = null, $street_number_id = null, $street_number_ext = null, $building_id = null, $building_name = null, $building_info_1 = null, $company_id = null, $company = null, $company_info_1 = null, $company_info_2 = null, $additional_info_7 = null)
    {
        // verify the required parameter 'request' is set
        if ($request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling searchLineGet'
            );
        }
        // verify the required parameter 'step' is set
        if ($step === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step when calling searchLineGet'
            );
        }
        // verify the required parameter 'country_code' is set
        if ($country_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_code when calling searchLineGet'
            );
        }
        // verify the required parameter 'language_code' is set
        if ($language_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language_code when calling searchLineGet'
            );
        }

        $resourcePath = '/SearchLine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request !== null) {
            $queryParams['request'] = ObjectSerializer::toQueryValue($request);
        }
        // query params
        if ($input_output !== null) {
            $queryParams['inputOutput'] = ObjectSerializer::toQueryValue($input_output);
        }
        // query params
        if ($step !== null) {
            $queryParams['step'] = ObjectSerializer::toQueryValue($step);
        }
        // query params
        if ($country_code !== null) {
            $queryParams['countryCode'] = ObjectSerializer::toQueryValue($country_code);
        }
        // query params
        if ($language_code !== null) {
            $queryParams['languageCode'] = ObjectSerializer::toQueryValue($language_code);
        }
        // query params
        if ($quality_code !== null) {
            $queryParams['qualityCode'] = ObjectSerializer::toQueryValue($quality_code);
        }
        // query params
        if ($locality_synonym !== null) {
            $queryParams['localitySynonym'] = ObjectSerializer::toQueryValue($locality_synonym);
        }
        // query params
        if ($locality_id !== null) {
            $queryParams['localityId'] = ObjectSerializer::toQueryValue($locality_id);
        }
        // query params
        if ($locality !== null) {
            $queryParams['locality'] = ObjectSerializer::toQueryValue($locality);
        }
        // query params
        if ($postal_code !== null) {
            $queryParams['postalCode'] = ObjectSerializer::toQueryValue($postal_code);
        }
        // query params
        if ($locality_flags !== null) {
            $queryParams['localityFlags'] = ObjectSerializer::toQueryValue($locality_flags);
        }
        // query params
        if ($street_id !== null) {
            $queryParams['streetId'] = ObjectSerializer::toQueryValue($street_id);
        }
        // query params
        if ($street_name !== null) {
            $queryParams['streetName'] = ObjectSerializer::toQueryValue($street_name);
        }
        // query params
        if ($street_flags !== null) {
            $queryParams['streetFlags'] = ObjectSerializer::toQueryValue($street_flags);
        }
        // query params
        if ($street_type !== null) {
            $queryParams['streetType'] = ObjectSerializer::toQueryValue($street_type);
        }
        // query params
        if ($street_synonym !== null) {
            $queryParams['streetSynonym'] = ObjectSerializer::toQueryValue($street_synonym);
        }
        // query params
        if ($street_info_1 !== null) {
            $queryParams['streetInfo_1'] = ObjectSerializer::toQueryValue($street_info_1);
        }
        // query params
        if ($street_info_2 !== null) {
            $queryParams['streetInfo_2'] = ObjectSerializer::toQueryValue($street_info_2);
        }
        // query params
        if ($street_info_5 !== null) {
            $queryParams['streetInfo_5'] = ObjectSerializer::toQueryValue($street_info_5);
        }
        // query params
        if ($street_number !== null) {
            $queryParams['streetNumber'] = ObjectSerializer::toQueryValue($street_number);
        }
        // query params
        if ($street_number_id !== null) {
            $queryParams['streetNumberId'] = ObjectSerializer::toQueryValue($street_number_id);
        }
        // query params
        if ($street_number_ext !== null) {
            $queryParams['streetNumberExt'] = ObjectSerializer::toQueryValue($street_number_ext);
        }
        // query params
        if ($building_id !== null) {
            $queryParams['buildingId'] = ObjectSerializer::toQueryValue($building_id);
        }
        // query params
        if ($building_name !== null) {
            $queryParams['buildingName'] = ObjectSerializer::toQueryValue($building_name);
        }
        // query params
        if ($building_info_1 !== null) {
            $queryParams['buildingInfo_1'] = ObjectSerializer::toQueryValue($building_info_1);
        }
        // query params
        if ($company_id !== null) {
            $queryParams['companyId'] = ObjectSerializer::toQueryValue($company_id);
        }
        // query params
        if ($company !== null) {
            $queryParams['company'] = ObjectSerializer::toQueryValue($company);
        }
        // query params
        if ($company_info_1 !== null) {
            $queryParams['companyInfo_1'] = ObjectSerializer::toQueryValue($company_info_1);
        }
        // query params
        if ($company_info_2 !== null) {
            $queryParams['companyInfo_2'] = ObjectSerializer::toQueryValue($company_info_2);
        }
        // query params
        if ($additional_info_7 !== null) {
            $queryParams['additionalInfo_7'] = ObjectSerializer::toQueryValue($additional_info_7);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyAddressGet
     *
     * Vérification de l'adresse après validation
     *
     * @param  string $request request (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $step step (optional, default to )
     * @param  string $locality_synonym Lieu dit postal ou INSEE. (optional)
     * @param  string $locality Localité. (optional)
     * @param  string $postal_code Code Postal. (optional)
     * @param  string $street_name Ligne 4 postale (voie). (optional)
     * @param  string $street_number Numéro de voie. (optional)
     * @param  string $street_number_ext Complément du numéro. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse (Complément d&#39;adresse 1). (optional)
     * @param  string $building_info1 Informations additionnelles du bâtiment (Complément d&#39;adresse 2). (optional)
     *
     * @throws \CapAddress\Address\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CapAddress\Address\Model\VerifyAddressResponse
     */
    public function verifyAddressGet($request, $country_code, $language_code, $step = '', $locality_synonym = null, $locality = null, $postal_code = null, $street_name = null, $street_number = null, $street_number_ext = null, $building_name = null, $building_info1 = null)
    {
        list($response) = $this->verifyAddressGetWithHttpInfo($request, $country_code, $language_code, $step, $locality_synonym, $locality, $postal_code, $street_name, $street_number, $street_number_ext, $building_name, $building_info1);
        return $response;
    }

    /**
     * Operation verifyAddressGetWithHttpInfo
     *
     * Vérification de l'adresse après validation
     *
     * @param  string $request (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $step (optional, default to )
     * @param  string $locality_synonym Lieu dit postal ou INSEE. (optional)
     * @param  string $locality Localité. (optional)
     * @param  string $postal_code Code Postal. (optional)
     * @param  string $street_name Ligne 4 postale (voie). (optional)
     * @param  string $street_number Numéro de voie. (optional)
     * @param  string $street_number_ext Complément du numéro. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse (Complément d&#39;adresse 1). (optional)
     * @param  string $building_info1 Informations additionnelles du bâtiment (Complément d&#39;adresse 2). (optional)
     *
     * @throws \CapAddress\Address\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CapAddress\Address\Model\VerifyAddressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyAddressGetWithHttpInfo($request, $country_code, $language_code, $step = '', $locality_synonym = null, $locality = null, $postal_code = null, $street_name = null, $street_number = null, $street_number_ext = null, $building_name = null, $building_info1 = null)
    {
        $returnType = '\CapAddress\Address\Model\VerifyAddressResponse';
        $request = $this->verifyAddressGetRequest($request, $country_code, $language_code, $step, $locality_synonym, $locality, $postal_code, $street_name, $street_number, $street_number_ext, $building_name, $building_info1);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CapAddress\Address\Model\VerifyAddressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation verifyAddressGetAsync
     *
     * Vérification de l'adresse après validation
     *
     * @param  string $request (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $step (optional, default to )
     * @param  string $locality_synonym Lieu dit postal ou INSEE. (optional)
     * @param  string $locality Localité. (optional)
     * @param  string $postal_code Code Postal. (optional)
     * @param  string $street_name Ligne 4 postale (voie). (optional)
     * @param  string $street_number Numéro de voie. (optional)
     * @param  string $street_number_ext Complément du numéro. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse (Complément d&#39;adresse 1). (optional)
     * @param  string $building_info1 Informations additionnelles du bâtiment (Complément d&#39;adresse 2). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyAddressGetAsync($request, $country_code, $language_code, $step = '', $locality_synonym = null, $locality = null, $postal_code = null, $street_name = null, $street_number = null, $street_number_ext = null, $building_name = null, $building_info1 = null)
    {
        return $this->verifyAddressGetAsyncWithHttpInfo($request, $country_code, $language_code, $step, $locality_synonym, $locality, $postal_code, $street_name, $street_number, $street_number_ext, $building_name, $building_info1)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyAddressGetAsyncWithHttpInfo
     *
     * Vérification de l'adresse après validation
     *
     * @param  string $request (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $step (optional, default to )
     * @param  string $locality_synonym Lieu dit postal ou INSEE. (optional)
     * @param  string $locality Localité. (optional)
     * @param  string $postal_code Code Postal. (optional)
     * @param  string $street_name Ligne 4 postale (voie). (optional)
     * @param  string $street_number Numéro de voie. (optional)
     * @param  string $street_number_ext Complément du numéro. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse (Complément d&#39;adresse 1). (optional)
     * @param  string $building_info1 Informations additionnelles du bâtiment (Complément d&#39;adresse 2). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyAddressGetAsyncWithHttpInfo($request, $country_code, $language_code, $step = '', $locality_synonym = null, $locality = null, $postal_code = null, $street_name = null, $street_number = null, $street_number_ext = null, $building_name = null, $building_info1 = null)
    {
        $returnType = '\CapAddress\Address\Model\VerifyAddressResponse';
        $request = $this->verifyAddressGetRequest($request, $country_code, $language_code, $step, $locality_synonym, $locality, $postal_code, $street_name, $street_number, $street_number_ext, $building_name, $building_info1);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyAddressGet'
     *
     * @param  string $request (required)
     * @param  string $country_code Chaîne de caractères représentant le code ISO 3166-1 alpha-3 sur trois caractères du pays pour lequel faire la recherche. (required)
     * @param  string $language_code Chaîne de caractères représentant le code ISO 639-1 identifiant la langue dans laquelle renvoyer les propositions. (required)
     * @param  string $step (optional, default to )
     * @param  string $locality_synonym Lieu dit postal ou INSEE. (optional)
     * @param  string $locality Localité. (optional)
     * @param  string $postal_code Code Postal. (optional)
     * @param  string $street_name Ligne 4 postale (voie). (optional)
     * @param  string $street_number Numéro de voie. (optional)
     * @param  string $street_number_ext Complément du numéro. (optional)
     * @param  string $building_name Libellé du complément d&#39;adresse (Complément d&#39;adresse 1). (optional)
     * @param  string $building_info1 Informations additionnelles du bâtiment (Complément d&#39;adresse 2). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function verifyAddressGetRequest($request, $country_code, $language_code, $step = '', $locality_synonym = null, $locality = null, $postal_code = null, $street_name = null, $street_number = null, $street_number_ext = null, $building_name = null, $building_info1 = null)
    {
        // verify the required parameter 'request' is set
        if ($request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling verifyAddressGet'
            );
        }
        // verify the required parameter 'country_code' is set
        if ($country_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_code when calling verifyAddressGet'
            );
        }
        // verify the required parameter 'language_code' is set
        if ($language_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language_code when calling verifyAddressGet'
            );
        }

        $resourcePath = '/VerifyAddress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request !== null) {
            $queryParams['request'] = ObjectSerializer::toQueryValue($request);
        }
        // query params
        if ($country_code !== null) {
            $queryParams['countryCode'] = ObjectSerializer::toQueryValue($country_code);
        }
        // query params
        if ($language_code !== null) {
            $queryParams['languageCode'] = ObjectSerializer::toQueryValue($language_code);
        }
        // query params
        if ($step !== null) {
            $queryParams['step'] = ObjectSerializer::toQueryValue($step);
        }
        // query params
        if ($locality_synonym !== null) {
            $queryParams['localitySynonym'] = ObjectSerializer::toQueryValue($locality_synonym);
        }
        // query params
        if ($locality !== null) {
            $queryParams['locality'] = ObjectSerializer::toQueryValue($locality);
        }
        // query params
        if ($postal_code !== null) {
            $queryParams['postalCode'] = ObjectSerializer::toQueryValue($postal_code);
        }
        // query params
        if ($street_name !== null) {
            $queryParams['streetName'] = ObjectSerializer::toQueryValue($street_name);
        }
        // query params
        if ($street_number !== null) {
            $queryParams['streetNumber'] = ObjectSerializer::toQueryValue($street_number);
        }
        // query params
        if ($street_number_ext !== null) {
            $queryParams['streetNumberExt'] = ObjectSerializer::toQueryValue($street_number_ext);
        }
        // query params
        if ($building_name !== null) {
            $queryParams['buildingName'] = ObjectSerializer::toQueryValue($building_name);
        }
        // query params
        if ($building_info1 !== null) {
            $queryParams['buildingInfo1'] = ObjectSerializer::toQueryValue($building_info1);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
